use serde::{Serialize, de::DeserializeOwned};

pub trait KeyValueStorage {
    fn read(&self, key: Vec<u8>) -> Option<Vec<u8>>;
    fn write(&self, key: Vec<u8>, value: Vec<u8>);
    fn remove(&self, key: Vec<u8>);

}

struct KeyValueStore {
    storage: Box<dyn KeyValueStorage>
}

impl KeyValueStore {
    fn read<Key: Serialize, Value: DeserializeOwned>(&self, key: Key) -> Option<Value> {

    }
    fn write<Key: Serialize, Value: Serialize>(&self, key: Key, value: Value);
    fn remove<Key: Serialize(&self, key: Key);
}

struct DefaultKeyValueStore {
    db_path: String
}

extern crate sled;

impl DefaultKeyValueStore {
    fn open_db(&self) -> sled::Db {
        sled::open(self.db_path.clone()).unwrap()
    }
}

impl KeyValueStorage for DefaultKeyValueStore {
    fn read(&self, key: Vec<u8>) -> Option<Vec<u8>> {
       Some(self.open_db().get(key).unwrap().unwrap().to_vec())
    }

    fn write(&self, key: Vec<u8>, value: Vec<u8>) {
        self.open_db().insert(key, value).unwrap();
    }

    fn remove(&self, key: Vec<u8>) {
        self.open_db().remove(key).unwrap();
    }
}
